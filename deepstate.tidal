do
    resetCycles
    let mylist = [1,2,6,3,50,14,31,34,2,6]
    let l = pure (length mylist)
    let pat = segment 4 $ (mylist !!) <$> (mod (sig floor) (l))
    d6 $ fast 8 $ s "jungbass" # n pat 


let "susan" = scale "minor" "c5"

d1 $ sound "superpiano"# let susan = scale "minor" "c4"

 d5 $ n " 0 1 3 [4*2]" # sound "808"# room 2 # sz 0.7

do
    resetCycles
    let mylist = [17,21,24,21,17,10,12]
    let pat = fastcat $ map pure mylist
    d7 $  n "x!4" # note pat # s "supersiren"
        # room ( segment 8 $ range 0 0.5 $ sine) 
        # sz ( segment 8 $ range 0 0.5 $ sine)

hush
let chordProgression = "<[^I*2] [^VI*4 ^IV] [^IV*4 ^VI] [[~ ~] ^I]>"

-- reset all streams
resetCycles

-- define a note pattern named "susan"
let susan = scale "minor" "c4"

-- send to first orbit
d1 $ sound "alphabet(5,8)" 
    # nTake "susan" [0 .. 4]
    # legato 1

hush

setS "melody" "c4 e4 g4 b4 d5"
d1 $ sound "superpiano" # nTake "melody" [0, 2, 4]

-- store a string pattern of note names
setS "melody" "c4 e4 g4 b4 d5"

-- play first 3 notes
d1 $ sound "superpiano" # note (nTake "melody" [0..2]) # legato 1

d1 $ sound "superpiano" # note (nTake "melody" [0..2]) # legato 1

scaleList

d1 $  n (scale "minor" "-7 -6 -5 -4 -3 -2 -1") #sound "superpiano"


d1 $  n (scale "minor" "0 1 2 3 4 5  6 7"|+"a") #sound "superpiano"


lookup "major" scaleTable

scaleList